<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>developToolsDescription</title>
    <url>/posts/4352/</url>
    <content><![CDATA[<h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p>最基本的复制是 y，粘贴是 p，剪切是 d。<br>复制和剪切的命令后面都可以接一个移动命令，表示将光标移动区间内的文本复制过来。<br>粘贴时 p 与 P 的区别是贴到光标前后的区别。<br>如果是在插入模式下想粘贴，也可以不退回普通模式，用 <code>ctrl+r再输入*</code> 来粘贴。</p>
<p>在窗格间切换的方法:</p>
<table>
<thead>
<tr>
<th>快捷键或者命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:bd+数字</code></td>
<td>删除指定缓存区的文件</td>
</tr>
<tr>
<td><code>Ctrl+w+方向键</code></td>
<td>切换到前／下／上／后一个窗格</td>
</tr>
<tr>
<td><code>Ctrl+w+h/j/k/l</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>:noh</code></td>
<td>取消高亮</td>
</tr>
</tbody>
</table>
<h2 id="eclipse"><a href="#eclipse" class="headerlink" title="eclipse"></a>eclipse</h2><p>eclipse快捷键</p>
<blockquote>
<p>ctrl+shift+f快捷键，自动排版<br>ctrl+shift+o快捷键，自动引入包<br>Alt+/ 代码助手完成一些代码的插入 ，自动显示提示信息</p>
</blockquote>
<h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>Ctrl + Alt + Shift + E  盖印图层 盖印可见图层,即将下面所有图层合并,但各自原图层仍保留<br>Ctrl + Alt + Shift + T  重复上一次ctrl+T的操作(可以累积效果),并且同时结果会放在新的复制图层(ctrl+shift+T,只重复,不复制)</p>
<h2 id="cmder"><a href="#cmder" class="headerlink" title="cmder"></a>cmder</h2><p>中文乱码问题:<br><code>win+ctrl+p</code>打开Settings<br>在Settings &gt; Startup &gt; Environment里添加：<code>set LANG=zh_CN.UTF8</code><br>PS：<br>这样修改过ls可以正确显示中文，但<code>ls |more</code>还是会出现乱码。<br>如果改为<code>set LANG=zh_CN.GBK</code>可以解决这个问题。</p>
<p>因为cat命令读取文件的编码与此有关，如果改为GBK则cat一个UTF8文件会显示乱码，<br>如果改为UTF8则cat一个GBK文件会显示乱码，<br>具体设置还是看你环境中常用编码。</p>
<h2 id="sublime"><a href="#sublime" class="headerlink" title="sublime"></a>sublime</h2><p>对于程序块缩进可用快捷键:<br>←左缩进ctrl+[<br>→右缩进ctrl+]，效果等同tab键<br>tab 往后缩，或者 shift+tab 往前缩</p>
<h2 id="staruml"><a href="#staruml" class="headerlink" title="staruml"></a>staruml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下载:http://staruml.io/</span><br><span class="line">破解方法:http://blog.csdn.net/mergades/article/details/46662413</span><br></pre></td></tr></table></figure>
<h2 id="Windows下带有空格的目录路径"><a href="#Windows下带有空格的目录路径" class="headerlink" title="Windows下带有空格的目录路径"></a>Windows下带有空格的目录路径</h2><p><code>set JAVA_HOME=C:\PROGRA~1\Java\jdk1.8.0_111</code><br>可以防止空格异常</p>
<h2 id="直接读取远程服务器的文件作为参数给某个命令使用"><a href="#直接读取远程服务器的文件作为参数给某个命令使用" class="headerlink" title="直接读取远程服务器的文件作为参数给某个命令使用"></a>直接读取远程服务器的文件作为参数给某个命令使用</h2><p>先下载wget到cmder/bin目录下:<br><a href="https://eternallybored.org/misc/wget/" target="_blank" rel="noopener">https://eternallybored.org/misc/wget/</a><br>然后直接远程读取:<br><code>wget -O- -q http://algs4.cs.princeton.edu/32bst/tinyST.txt | cat</code></p>
<h2 id="将-Markdown-转成漂亮的脑图"><a href="#将-Markdown-转成漂亮的脑图" class="headerlink" title="将 Markdown 转成漂亮的脑图"></a>将 Markdown 转成漂亮的脑图</h2><p>MarkRemap   有各个平台的版本，开源<br>还可以结合hexo的 <a href="https://github.com/HunterXuan/hexo-simple-mindmap" target="_blank" rel="noopener">https://github.com/HunterXuan/hexo-simple-mindmap</a> 插件</p>
<h2 id="其他实用工具"><a href="#其他实用工具" class="headerlink" title="其他实用工具"></a>其他实用工具</h2><blockquote>
<p>U盘资料还原软件:badcopy<br>视频桌面软件:DreamScene<br>flash反编译:Sothink SWF Decompiler<br>cmd替代品:<a href="http://www.jianshu.com/p/b691b48bcee3" target="_blank" rel="noopener">cmder</a><br>用文字画uml图:plantuml<br>保存剪切板里的图片到本地文件:Screenshot2Disk<br>截图工具:FastStone,Sharex<br>打开dll文件:Resource Hacker<br>windows下的软件包管理工具:Chocolatey<br>虚拟机管理工具:Vagrant(没用过,据说好用)<br>反编译jar:jd-gui<br>局域网会议软件:InletexEMC<br>excel插件:PyXLL(能直接执行python脚本)</p>
</blockquote>
<hr>
<blockquote>
<p><strong>版权声明:</strong><br>本文首发于<a href="https://godtree94.github.io">GODTREE 博客</a>，版权所有，侵权必究，转载请注明出处。<br>本文永久链接：<a href="https://godtree94.github.io/posts/4352/">https://godtree94.github.io/posts/4352/</a></p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>开发工具技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>initMyBlogDone</title>
    <url>/posts/18588/</url>
    <content><![CDATA[<p>说起搭建博客,发现以前的我真的很折腾,用过WordPress,折腾各种主题各种插件,好不容易折腾完了放到了sae上,又搞下seo优化,到头来发现,真正写的文章少,质量也不行,后面干脆就都写在自己的txt文件里面存起来好了</p>
<p>直到最近做项目看别人的博客看多了,发现好多大牛都直接把博客放在github pages上,是静态博客,想着又不用自己去操作貌似功能很强大的管理后台,于是我决定动刀了,于是有了现在这个我很喜欢的博客,应该不会再换了!</p>
<p>搭建的思路先写下:</p>
<ol>
<li>安装node环境(需要有npm)</li>
<li>用npm安装hexo-cli,并用hexo命令初始化一个文件夹,这个文件夹就相当于博客的静态页面生成工具,自带服务器环境</li>
<li>配置git的ssh私钥,方便hexo deploy的时候调用git push时候不用输入密码(其实一开始我以为这一步骤是可以忽略的,但是试了下发现不成功,不知道哪一步错了还是真的不行,也没再试了,反正配个ssh也不难)</li>
<li>hexo部署到github pages</li>
</ol>
<h2 id="安装node环境-需要有npm"><a href="#安装node环境-需要有npm" class="headerlink" title="安装node环境(需要有npm)"></a>安装node环境(需要有npm)</h2><p>用的Windows装的,nodejs安装包官网上下载,安装完后自带npm</p>
<h2 id="安装hexo-cli"><a href="#安装hexo-cli" class="headerlink" title="安装hexo-cli"></a>安装hexo-cli</h2><p>npm原本的源太慢了,所以用了阿里的npm源,npm就是一个包管理器,跟maven差不多,maven的中央仓库相信用过的知道速度如何…记得全局安装(-g)哦,安装完就有hexo命令了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm --registry https://registry.npm.taobao.org install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>你想安装你的博客生成工具到哪,比如E://blog,就到E盘目录下,按<code>shift+鼠标右键</code>,点击打开当前目录的命令行,用hexo命令初始化,然后可以去喝杯茶等待安装完成…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm --registry https://registry.npm.taobao.org install</span><br></pre></td></tr></table></figure>
<p>安装完了后,hexo的几个命令你都可以用了,除了hexo deploy(因为这个是部署用的,还没配部署呢),先来看下demo效果先</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p><img src="/uploads/images/hexo启动成功.PNG" alt="hexo启动成功"></p>
<p>还不赶紧打开浏览器看看效果!</p>
<h2 id="配置git的ssh秘钥"><a href="#配置git的ssh秘钥" class="headerlink" title="配置git的ssh秘钥"></a>配置git的ssh秘钥</h2><p>git首先要配置下email和name先,代码提交的时候会有你的个人信息,这样有什么问题别人可以找你,毕竟email是程序猿每天都得关注的</p>
<p>这里说个技巧,git config有全局的和当前git项目下的,全局的建议用你的个人最常用邮箱和个人昵称,因为学习技术嘛是很漫长的过程,自己学写一些自己练习的代码呀或者私人项目是贯穿于整个职业道路上的,比较固定,至于用公司邮箱和公司昵称的,谁知道你下个月是不是准备跳槽了呢,所以,公司项目的话,配config不要配置成全局较好,接到一个项目配这个项目的config,下面准备配置全局的git config了哦</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;自己的邮箱地址&quot;</span><br><span class="line">git config --global user.name &quot;自己的昵称&quot;</span><br></pre></td></tr></table></figure>
<p>很多新手都很不明白git的ssh是什么原理,这里简单说明下,首先在本地生成ssh公钥和私钥,公钥呢,就相当于两兄弟,同个父母生的,公钥呢放到github上,相当于在github当接头人,私钥在你本机的电脑上,你呢,用这把私钥去访问github,哦,你的兄弟认出你了,放行,有人际关系就是好呀,连密码都不用输了呵呵</p>
<p>这里要说下你的个人项目和公司的项目有多个git ssh秘钥怎么分开管理,先贴下我的~/.ssh目录下的结构</p>
<p><img src="/uploads/images/git-ssh_文件夹结构.PNG" alt="git-ssh_文件夹结构"></p>
<p><code>known_hosts</code>文件记录了用git ssh尝试过通信的服务器地址,是git会自动生成的,不用管</p>
<p><code>ssh-keygen</code>是生成公钥和秘钥的工具,自动默认会生成在电脑个人目录下的.ssh文件夹,默认名称为id_rsa何id_rsa.pub(公钥,public的缩写后缀,放在git服务器上的),建议那个git服务器上的,要加个后缀好辨别点,比如github的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C &quot;你的邮箱地址&quot;</span><br></pre></td></tr></table></figure>
<p>一路回车(如果你想给私钥也设置个密码的话,就输入下密码,但是这样的话每次push就还得输入你设置的私钥密码;如果不想的话,回车默认免密码),生成后,要自己写个config文件,放在.ssh文件夹下</p>
<p><img src="/uploads/images/git-ssh_config文件样例.PNG" alt="git-ssh_config文件样例"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line"> IdentityFile C:\Users\john\.ssh\id_rsa.github</span><br><span class="line"> User godtree94</span><br></pre></td></tr></table></figure>
<p>自己修改成自己相应的信息,这个会修改吧,修改完就差把<code>id_rsa.github.pub</code>的内容放上github的ssh设置的地方了,记得别有多余的空格哦,这个不懂的话百度<code>github添加ssh公钥</code>,懒得找图了</p>
<p>配置完了后,测试下行不行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>看到提示信息:<code>You&#39;ve successfully authenticated, but GitHub does not provide shell access</code>,恭喜你已经成功了</p>
<h2 id="hexo部署到github-pages"><a href="#hexo部署到github-pages" class="headerlink" title="hexo部署到github pages"></a>hexo部署到github pages</h2><p>部署的流程是这样的:执行hexo deploy后,生成<code>.deploy_git</code>文件夹(该文件夹里面实际就是生成的博客静态页面),并把该文件夹<code>git init</code>初始化,hexo会去当前目录下读取<code>_config.yml</code>文件的deploy配置部分,把刚才生成的<code>.deploy_git</code>push上github的仓库</p>
<h3 id="新建github仓库"><a href="#新建github仓库" class="headerlink" title="新建github仓库"></a>新建github仓库</h3><p>建立仓库名的格式为:<code>&#39;用户名&#39;.github.io</code>,比如john.github.io,用户名跟你github的名字一样,而且不能包含大写字母,以下都假定github的用户名为john</p>
<h3 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h3><p>打开<code>_config.yml</code>文件,到最底部发现有<code>deploy:...</code>的属性<br>这里有两种配置,一种是hexo3.0之前的版本,一种是hexo3.0之后的版本,我的版本是3.2.2,我的配置是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: http://github.com/john/john.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">  message: test</span><br></pre></td></tr></table></figure>
<p>只要替换用户名为自己的就行了,记得冒号后面要有空格,有点像python的语法,肯定是强迫症的人写的hexo</p>
<h3 id="hexo部署"><a href="#hexo部署" class="headerlink" title="hexo部署"></a>hexo部署</h3><p>配置无误后,清理下hexo的缓存,生成静态页面文件,部署:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p><img src="/uploads/images/hexo-deploy-success.PNG" alt="hexo-deploy-success"></p>
<p>看到done了,就证明成功了,赶紧输入<code>john.github.io</code>试下呗</p>
<p>至于hexo怎么新建文章,怎么换主题等等,自己探索吧,hexo真的超赞!终于可以安心的用sublime写博客了!</p>
<hr>
<blockquote>
<p><strong>版权声明:</strong><br>本文首发于<a href="https://godtree94.github.io">GODTREE 博客</a>，版权所有，侵权必究，转载请注明出处。<br>本文永久链接：<a href="https://godtree94.github.io/posts/18588/">https://godtree94.github.io/posts/18588/</a></p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>Github Pages</tag>
      </tags>
  </entry>
  <entry>
    <title>javaBase</title>
    <url>/posts/45792/</url>
    <content><![CDATA[<h2 id="public-private-protected-及不写时的区别"><a href="#public-private-protected-及不写时的区别" class="headerlink" title="public ,private ,protected 及不写时的区别"></a>public ,private ,protected 及不写时的区别</h2><p><code>注意:不写时默认为friendly</code><br>各个作用域所起的作用如下:</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>当前类</th>
<th>同一package</th>
<th>子孙类</th>
<th>其他package</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>friendly</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<h2 id="为什么编译出的class的文件名有些带有-1-2这种"><a href="#为什么编译出的class的文件名有些带有-1-2这种" class="headerlink" title="为什么编译出的class的文件名有些带有$1,$2这种"></a>为什么编译出的class的文件名有些带有$1,$2这种</h2><p>Those are the <code>.class</code> files that hold the anonymous inner classes.<br>参考资料:<br><a href="https://stackoverflow.com/questions/1075207/what-are-the-1-in-class-file" target="_blank" rel="noopener">https://stackoverflow.com/questions/1075207/what-are-the-1-in-class-file</a></p>
<h2 id="Java不允许只有返回类型不同的方法重载"><a href="#Java不允许只有返回类型不同的方法重载" class="headerlink" title="Java不允许只有返回类型不同的方法重载"></a>Java不允许只有返回类型不同的方法重载</h2><p>在<code>同一个类</code>中，无论返回值、访问修饰符是否相同，方法名必须相同，参数列表必须不参相同。</p>
<p>因为Java语言层面上<code>overload resolution</code>只看方法名和参数列表的类型，不看返回值类型。<br>如果<code>overload resolution</code>发现方法名+参数列表找到了多个版本匹配度一样，那<code>overload resolution</code>就以“冲突”失败。</p>
<p>在JVM层面上，其实是允许同一个类里有多个同名同参数的方法只在返回值类型上不同。但这个特点没有暴露给Java语言（甚至反射API也处理不了这个特点，只有新的MethodHandle API能处理）。</p>
<h2 id="协变式覆盖和泛型重载"><a href="#协变式覆盖和泛型重载" class="headerlink" title="协变式覆盖和泛型重载"></a>协变式覆盖和泛型重载</h2><h3 id="协变式覆盖"><a href="#协变式覆盖" class="headerlink" title="协变式覆盖"></a>协变式覆盖</h3><p>只要子类方法与超类方法具有相同的方法签名，或者子类方法的返回值是超类方法的子类型(增加了对协变返回值的支持)，就可以覆盖。</p>
<h3 id="泛型重载"><a href="#泛型重载" class="headerlink" title="泛型重载"></a>泛型重载</h3><p>JDK7、8是不可以编译的，需要用JDK6才可以<br>泛型擦除指的是:比如<code>List&lt;String&gt;</code>和<code>List&lt;Integer&gt;</code>,擦除后都变成<code>List</code><br>如果两个泛型方法在擦除泛型信息后，如果只是具有相同的参数类型，而返回值不一样，就可以进行重载；</p>
<p><img src="泛型覆盖.png" alt="泛型覆盖"></p>
<h2 id="enum类型的弊端"><a href="#enum类型的弊端" class="headerlink" title="enum类型的弊端"></a>enum类型的弊端</h2><p>使用枚举类型进行映射有一个弊端就是,将来有一天修改了枚举类型的定义,<code>会造成数据库中的数据无法被加载</code>,所以如果对改动的枚举定义(如顺序调整了– ORDINAL;或名称改了;或增减了选项)时一定要同步update数据库中的记录,这对于产品数据库也是个麻烦事. 这一点上还是需要谨慎的思考是否真要用 Java 的枚举值来映射.<br>而用 Integer 或 String 来作为 Java 的属性时则不会造成数据加载的异常,顶多是数据混乱,或有些值无法理解而已.<br>所以,对于一些常用而又量不大的数据,可以一次性把它的映射关系加载进缓存里面,可以考虑用guava–谷歌开源一个jar,其中的BiMap很好用,但是要注意右边要保证唯一性,比如下面这个不能同时是22L</p>
<p><img src="bimap例子1.png" alt="bimap例子1"></p>
<p>还有下面这个例子,左边的key重复了,会以后面执行的为主:</p>
<p><img src="bimap例子2.png" alt="bimap例子2"></p>
<h2 id="HashMap-LinkedHashMap与TreeMap"><a href="#HashMap-LinkedHashMap与TreeMap" class="headerlink" title="HashMap,LinkedHashMap与TreeMap"></a>HashMap,LinkedHashMap与TreeMap</h2><p>HashMap不保证数据有序，LinkedHashMap保证数据可以保持插入顺序，而如果我们希望Map可以保持key的大小顺序的时候，我们就需要利用TreeMap了。</p>
<p><a href="http://yikun.github.io/2015/04/06/Java-TreeMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">http://yikun.github.io/2015/04/06/Java-TreeMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</a></p>
<h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><ol>
<li>异常的继承结构：基类为Throwable，Error和Exception继承Throwable，RuntimeException和IOException等继承Exception，具体的RuntimeException继承RuntimeException。 </li>
<li>Error和RuntimeException及其子类成为未检查异常（unchecked），其它异常成为已检查异常（checked）。</li>
</ol>
<p><img src="异常类的关联.png" alt="异常类的关联"></p>
<hr>
<blockquote>
<p><strong>版权声明:</strong><br>本文首发于<a href="https://godtree94.github.io">GODTREE 博客</a>，版权所有，侵权必究，转载请注明出处。<br>本文永久链接：<a href="https://godtree94.github.io/posts/45792/">https://godtree94.github.io/posts/45792/</a></p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>javaClassLoader</title>
    <url>/posts/2135/</url>
    <content><![CDATA[<h2 id="了解ClassLoader的好处"><a href="#了解ClassLoader的好处" class="headerlink" title="了解ClassLoader的好处"></a>了解ClassLoader的好处</h2><p>有助于了解java类的加载机制,了解web应用服务器是怎么加载进war包并怎么工作的</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol>
<li>相信很多人都会在各种文章中见到<code>AppClassloader</code>和<code>SystemClassloader</code>,其实这两个是指同一个东西,只是叫法不同.</li>
<li><code>ClassLoader.getSystemResourceAsStream(name);</code>类似这种,ClassLoader有且仅有提供了几个方法跟systemloader有关的方法.</li>
<li>Bootstrap是爷爷、ExtClassLoader是爸爸、AppClassLoader是孩子（孙子）。但由于爸爸ExtClassLoader太忙了，所以照顾孩子AppClassLoader的责任就有爷爷Bootstrap来处理了(意思是，虽然ExtClassLoader是AppClassLoader老爸，但却是由爷爷Bootstrap加载的AppClassLoader。该情况与中国国情完全一样)。</li>
<li>项目的配置文件的覆盖顺序为：根类加载器 &gt; 扩展类加载器 &gt; 应用中的资源文件 &gt; 应用所依赖的第三方jar </li>
</ol>
<h2 id="各个ClassLoader的关联"><a href="#各个ClassLoader的关联" class="headerlink" title="各个ClassLoader的关联"></a>各个ClassLoader的关联</h2><p>普通java项目:<br><code>AppClassLoader</code>&gt;&gt;<code>ExtClassLoader</code>&gt;&gt;<code>bootstrapLoader</code><br>glassfish web项目:<br><code>WebappClassLoader</code>&gt;&gt;<code>DelegatingClassLoader</code>&gt;&gt;<code>URLClassLoader</code>&gt;&gt;<code>APIClassLoader</code>&gt;&gt;<code>ExtClassLoader</code>&gt;&gt;<code>bootstrapLoader</code></p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>有一次我在编写一个sdk,打算把它打包成jar,给另外的web应用使用,姑且叫该项目为B工程;<br>A工程(web项目)依赖B工程,在B工程中的classpath下有个配置文件plugins.xml,同时在A工程的classpath下也有一个同名的配置文件,那么<strong>A工程下的配置文件则会覆盖B下的文件,同样包路径的class文件也会覆盖</strong>。</p>
<p>所以,如果我在A工程下写一个配置文件<code>plugins.xml</code>,那么它打包成war文件的时候会覆盖B工程jar包里面的配置文件<code>plugins.xml</code>,然后在glassfish上运行war包的时候会被<br>WebAppClassLoader加载(如果是java项目则会被AppClassloader获取到)</p>
<p>下面是项目中用到的部分代码:<br><img src="ClassLoader1.png" alt="读取配置文件"></p>
<p><img src="ClassLoader2.png" alt="深挖代码1"></p>
<p>这里解释下,因为BootstrapLoader是jvm底层实现,没有具体实现的Class类,所以如果获取到的ClassLoader为null,则表示是由BootstrapLoader加载的;<br>所以这里的逻辑为:如果是bootstraploader,但是因为bootstraploader下肯定没有资源文件,就获取systemloader下的资源文件<br>如果不是bootstraploader,就直接取得classloader然后调用getResourceAsStream方法</p>
<p><img src="ClassLoader3.png" alt="深挖代码2"></p>
<p><img src="ClassLoader4.png" alt="深挖代码3"></p>
<p>这里的findResource是每个继承了ClassLoader的类可以自行实现的方法,是为了自定义自己独特的加载方法.</p>
<p>getResource方法,是委托模型,先遍历到最顶部的ClassLoader(即bootstrapClassLoader),如果找到直接返回url,如果找不到,就找extClassLoader,这样逐渐遍历.</p>
<p>逻辑是这样的,从WebappClassLoader开始找,儿子让父亲去找,父亲让自己的父亲去找…到了bootstrapClassLoader了,自己都是祖先了,没有父亲可以找了,所以调用自己的getBootstrapResource方法找,找不到,再继续调用自己独特的方法findResource找,还是找不到,只能返回null给儿子,儿子说”父亲找不到,只能自己找了”,所以调用自己独特的方法findResource去找,结果也找不到,再继续交给儿子…直到后面WebappClassLoader自己找到了…你说为什么WebappClassLoader一开始不自己找呢,这就是所谓的委托模型…</p>
<blockquote>
<p>依次遍历的顺序如下:<br>org.glassfish.web.loader.WebappClassLoader<br>org.glassfish.internal.api.DelegatingClassLoader<br>java.net.URLClassLoader<br>APIClassLoader<br>ExtClassLoader——ext下的jar里面<br>bootstrapLoader——–jre/classes下</p>
</blockquote>
<p>看下图可能更理解点,我把配置文件放在classpath的包里面,然后最外层的项目没有配置文件:<br><img src="ClassLoader5.png" alt="深挖代码4"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="http://blog.csdn.net/lyjshen/article/details/52421554" target="_blank" rel="noopener">http://blog.csdn.net/lyjshen/article/details/52421554</a></p>
</blockquote>
<hr>
<blockquote>
<p><strong>版权声明:</strong><br>本文首发于<a href="https://godtree94.github.io">GODTREE 博客</a>，版权所有，侵权必究，转载请注明出处。<br>本文永久链接：<a href="https://godtree94.github.io/posts/2135/">https://godtree94.github.io/posts/2135/</a></p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>Classloader</tag>
      </tags>
  </entry>
  <entry>
    <title>javaIO</title>
    <url>/posts/12425/</url>
    <content><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>java IO框架是java开发中最常用到的,通常用于读取,写入文件.</p>
<h2 id="关于编码"><a href="#关于编码" class="headerlink" title="关于编码"></a>关于编码</h2><p>jvm使用无编码的Unicode字符存储字符串于内存中</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>说起使用方法之前,这里先给两张思维导图,认识下java IO的各个类的关系:</p>
<img src="/posts/12425/IO框架大的体系.png" title="IO框架大的体系图">
<img src="/posts/12425/IO框架小的体系.png" title="IO框架小的体系图">
<h3 id="文件编码跟系统的编码不一致"><a href="#文件编码跟系统的编码不一致" class="headerlink" title="文件编码跟系统的编码不一致"></a>文件编码跟系统的编码不一致</h3><p>这个时候就要进行转换(假设文件的编码是UTF8,而系统的编码是GBK):<br>File–&gt;(转换成字节)FileInputStream–&gt;(对字节进行UTF8读取,转换成Reader字符)InputStreamReader–&gt;(加个缓冲,这个缓冲有read和readLine方法)BufferedReader.</p>
<p>例子如下:<br><img src="例子1.png" alt="例子1.png"></p>
<h3 id="文件的编码跟系统的编码一致"><a href="#文件的编码跟系统的编码一致" class="headerlink" title="文件的编码跟系统的编码一致"></a>文件的编码跟系统的编码一致</h3><p>Reader类其实是可以直接接收File作为参数的,这个时候会转换成字节,然后对字节按照系统的编码进行读取,例子如下:<br><img src="例子2.png" alt="例子2.png"></p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="read与readLine的区别"><a href="#read与readLine的区别" class="headerlink" title="read与readLine的区别"></a>read与readLine的区别</h3><p>read如果结束了返回-1,如果没结束返回char类型(一个中文算一个字符);<br>readLine如果结束了返回null,如果没结束返回String类型.</p>
<h3 id="bufferedInputStream与dataInputStream的区别"><a href="#bufferedInputStream与dataInputStream的区别" class="headerlink" title="bufferedInputStream与dataInputStream的区别"></a>bufferedInputStream与dataInputStream的区别</h3><p>dataInputStream(bufferedInputStream),包裹层…<br>如果您正在做一些特别的尝试将类的字段序列化到文件中，那么您可以使用DataInput / OutputStream，因为它可以在二进制级别更好地控制数据。</p>
<hr>
<blockquote>
<p><strong>版权声明:</strong><br>本文首发于<a href="https://godtree94.github.io">GODTREE 博客</a>，版权所有，侵权必究，转载请注明出处。<br>本文永久链接：<a href="https://godtree94.github.io/posts/12425/">https://godtree94.github.io/posts/12425/</a></p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>java IO 框架</tag>
      </tags>
  </entry>
  <entry>
    <title>knowledgeMap</title>
    <url>/posts/90001/</url>
    <content><![CDATA[<h1 id="个人后端知识体系整理（完善中）"><a href="#个人后端知识体系整理（完善中）" class="headerlink" title="个人后端知识体系整理（完善中）"></a>个人后端知识体系整理（完善中）</h1><blockquote class="pullquote mindmap mindmap-md"><ul>
<li>中心节点<ul>
<li>数据结构与算法<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI5ODI5NDkxMw==&amp;mid=2247490825&amp;idx=2&amp;sn=5c26af13d00976295786c65d41f768a6&amp;chksm=eca956e7dbdedff127be68312e384d4c3ff671feb8e4b0867902bbd2b2398291dad80dcf6362&amp;mpshare=1&amp;scene=1&amp;srcid=0630IutraEvQosrBFR6EloKH&amp;sharer_sharetime=1593508521706&amp;sharer_shareid=f433210a053adb795a013ded9465017f&amp;key=69fdb5ac5982b1743f42e86e4d74ca614d6af9885ffa4f960b0a60322c9cdcbf33d4a61e4ff57bbb3a86bed118741c19b63779c95229e4469e22b33626eb69025d0902fe4b23ad66d7a1bcb48127adb1&amp;ascene=1&amp;uin=Mjg5MDEzNzIwNA%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=Axq9aPV8CLjRvbHvh5zppDo%3D&amp;pass_ticket=3DrEaHrX3hmWfS7vcYGmWF%2F6kyksnJeIjhsv7%2B8Azo1X0N8xSy0%2BHx8leRIlpnn9" target="_blank" rel="noopener">排序算法</a><ul>
<li>比较类排序<ul>
<li>交换排序</li>
<li>插入排序</li>
<li>选择排序</li>
<li>归并排序</li>
</ul>
</li>
<li>非比较类排序<ul>
<li>计数排序</li>
<li>桶排序</li>
<li>基数排序</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI2NjA3NTc4Ng==&amp;mid=2652083049&amp;idx=1&amp;sn=6ab60b065836ccbb960ac1c9fdf20771&amp;chksm=f174988cc603119a59d141c9a2d8144f0d56d09112d8f68055adeb266f0aa9c526581f2650df&amp;mpshare=1&amp;scene=24&amp;srcid=0625vppe7eiz8AETXmXfGEHg&amp;sharer_sharetime=1593065345010&amp;sharer_shareid=f433210a053adb795a013ded9465017f&amp;key=82c238abbe3b82ba7cfad489ccf47c752ccc359c9faad1d518a2be1b48139aeb73df8cc6f08c6dc5fd19991354ecd39f36c5275ad3446e3d1f61e721576e4ddec9179911575742ae76285226bfae4bbf&amp;ascene=14&amp;uin=Mjg5MDEzNzIwNA%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=A%2BAajt567Hs2G6qP8RXDrZc%3D&amp;pass_ticket=3DrEaHrX3hmWfS7vcYGmWF%2F6kyksnJeIjhsv7%2B8Azo1X0N8xSy0%2BHx8leRIlpnn9&amp;winzoom=1" target="_blank" rel="noopener">树</a><ul>
<li>多路搜索树<ul>
<li>普通多路搜索树</li>
<li>平衡多路搜索树<ul>
<li>B树</li>
<li>B+树</li>
</ul>
</li>
</ul>
</li>
<li>二叉搜索树<ul>
<li>普通二叉搜索树<ul>
<li>BST</li>
</ul>
</li>
<li>平衡二叉搜索树<ul>
<li>AVL</li>
<li>Red-Black-Tree</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>图</li>
</ul>
</li>
<li>计算机网络<ul>
<li>tcp/ip四层模型<ul>
<li>tcp<ul>
<li>三次握手,四次挥手</li>
</ul>
</li>
<li>udp</li>
</ul>
</li>
</ul>
</li>
<li>java<ul>
<li>java基础<ul>
<li>多线程<ul>
<li>wait notify</li>
<li>线程池</li>
<li>线程实现</li>
</ul>
</li>
<li>JVM<ul>
<li>判断能否gc<ul>
<li>引用计数算法（Reference Counting）</li>
<li>根搜索算法（GC Root Tracing）</li>
</ul>
</li>
<li>gc类型<ul>
<li>Minor GC</li>
<li>Full GC（Major GC）</li>
</ul>
</li>
<li><a href="https://www.cnblogs.com/aspirant/p/8662690.html" target="_blank" rel="noopener">gc回收算法</a><ul>
<li>标记清除（mark-sweep）</li>
<li>标记复制（mark-copy）</li>
<li>标记整理（mark-compact）</li>
<li>分代收集（generational-collection）</li>
</ul>
</li>
<li>内存结构<ul>
<li>堆<ul>
<li><a href="https://www.cnblogs.com/jswang/p/9056038.html" target="_blank" rel="noopener">新生代</a><ul>
<li>Eden</li>
<li>S1（Survivor1）</li>
<li>S2（Survivor2）</li>
</ul>
</li>
<li>老年代</li>
</ul>
</li>
<li>方法区</li>
<li>栈</li>
<li>程序计数器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>框架源码解析<ul>
<li>spring源码<ul>
<li>aop</li>
<li>ioc<ul>
<li>循环依赖，三级缓存</li>
</ul>
</li>
</ul>
</li>
<li>jdk源码<ul>
<li>hashmap<ul>
<li>hashcode</li>
<li>capity</li>
<li>容积因子</li>
</ul>
</li>
</ul>
</li>
<li>mybatis-spring源码</li>
</ul>
</li>
<li>开源组件<ul>
<li>k8s<ul>
<li>pod</li>
<li>controller</li>
<li>service</li>
<li>integres</li>
</ul>
</li>
<li>redis</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p><strong>版权声明:</strong><br>本文首发于<a href="https://godtree94.github.io">GODTREE 博客</a>，版权所有，侵权必究，转载请注明出处。<br>本文永久链接：<a href="https://godtree94.github.io/posts/90001/">https://godtree94.github.io/posts/90001/</a></p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>myFrontEndWorks</title>
    <url>/posts/36228/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>友情提示:此页面延迟大,自备梯子,效果更佳~~~ </p>
</blockquote>
<h2 id="d3-柱状图-官网demo"><a href="#d3-柱状图-官网demo" class="headerlink" title="d3-柱状图(官网demo)"></a>d3-柱状图(官网demo)</h2>
<script async src="//jsfiddle.net/godtreeGGG/0qx8x0oL/embed/result,js,html,css/"></script>

<h2 id="上拉效果"><a href="#上拉效果" class="headerlink" title="上拉效果"></a>上拉效果</h2>
<script async src="//jsfiddle.net/godtreeGGG/qtbdsqfx/embed/result,html,css/"></script>

<h2 id="echarts"><a href="#echarts" class="headerlink" title="echarts"></a>echarts</h2><h3 id="仪表盘"><a href="#仪表盘" class="headerlink" title="仪表盘"></a>仪表盘</h3>
<script async src="//jsfiddle.net/godtreeGGG/waf66rgp/embed/result,js,html/"></script>

<h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3>
<script async src="//jsfiddle.net/godtreeGGG/xjta89wp/embed/result,js,html/"></script>

<h3 id="折线图2"><a href="#折线图2" class="headerlink" title="折线图2"></a>折线图2</h3>
<script async src="//jsfiddle.net/godtreeGGG/jkewbx66/embed/result,js,html/"></script>

<h3 id="折线图3"><a href="#折线图3" class="headerlink" title="折线图3"></a>折线图3</h3>
<script async src="//jsfiddle.net/godtreeGGG/cme8uhc3/embed/result,js,html/"></script>

<h3 id="折线图-amp-条形图"><a href="#折线图-amp-条形图" class="headerlink" title="折线图&amp;条形图"></a>折线图&amp;条形图</h3>
<script async src="//jsfiddle.net/godtreeGGG/orja0d4r/embed/result,js,html/"></script>

<h3 id="扇形图"><a href="#扇形图" class="headerlink" title="扇形图"></a>扇形图</h3>
<script async src="//jsfiddle.net/godtreeGGG/w7e62xdf/embed/result,js,html/"></script>

<h3 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h3>
<script async src="//jsfiddle.net/godtreeGGG/vh7bjzaw/embed/result,js,html/"></script>

<h3 id="横向柱状图"><a href="#横向柱状图" class="headerlink" title="横向柱状图"></a>横向柱状图</h3>
<script async src="//jsfiddle.net/godtreeGGG/ejt7gs9c/embed/result,js,html/"></script>

<hr>
<blockquote>
<p><strong>版权声明:</strong><br>本文首发于<a href="https://godtree94.github.io">GODTREE 博客</a>，版权所有，侵权必究，转载请注明出处。<br>本文永久链接：<a href="https://godtree94.github.io/posts/36228/">https://godtree94.github.io/posts/36228/</a></p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>regexNote</title>
    <url>/posts/37573/</url>
    <content><![CDATA[<h1 id="正则的用途"><a href="#正则的用途" class="headerlink" title="正则的用途"></a>正则的用途</h1><p>在很多地方都会用到正则表达式,如果熟练掌握正则,在爬虫,一些渗透实验中会占有优势</p>
<h1 id="正则的发展历程"><a href="#正则的发展历程" class="headerlink" title="正则的发展历程"></a>正则的发展历程</h1><p>看了一些总结正则发展历程的文章,我想大概总结下正则的几种标准:</p>
<p>从一开始的grep,再到egrep( 这里的e表示extended，加强版的意思,支持了+、|与?这三个元符号，并且可以在分组中使用*，分组可以直接写成(…)，同时用\1,\2…来引用分组。 )诞生,再到一系列类似sed,awk类的程序产生,这是时候是正则发展的混乱期,因为始终都没有一个标准.</p>
<blockquote>
<p>这种混乱度情况一直持续到了1986年。在1986年，POSIX（Portable Operating System Interface）标准公诸于世，POSIX制定了不同的操作系统都需要遵守的一套规则，当然，正则表达式也包括其中。</p>
<p>当然，除了POSIX标准外，还有一个Perl分支，也就是我们现在熟知的PCRE，随着Perl语言的发展，Perl语言中的正则表达式功能越来越强悍，为了把Perl语言中正则的功能移植到其他语言中，PCRE就诞生了。现在的编程语言中的正则表达式，大部分都属于PCRE这个分支。</p>
</blockquote>
<h1 id="正则标准分类"><a href="#正则标准分类" class="headerlink" title="正则标准分类"></a>正则标准分类</h1><h2 id="POSIX标准"><a href="#POSIX标准" class="headerlink" title="POSIX标准"></a>POSIX标准</h2><p>POSIX把正则表达式分为两种（favor）：BRE（Basic Regular Expressions）与ERE（Extended Regular Expressions ）。所有的POSIX程序可以选择支持其中的一种。具体对比引用别人的图,如下表：<br><img src="2017-09-28 10-21-40.png" alt="BRE和ERE的区别"></p>
<p>翻译过来就是:</p>
<table>
<thead>
<tr>
<th>正则功能</th>
<th>BREs</th>
<th>EREs</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.,^,$,[...],[!...]</code>这四种用法</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>用<code>*</code>代表任意数量的字符匹配</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>用<code>+,?</code>分别代表一个以上和任意多个的字符匹配</td>
<td></td>
<td>支持</td>
</tr>
<tr>
<td>范围确定</td>
<td>写法例子为\{1,10\}</td>
<td>写法例子为{1,10}</td>
</tr>
<tr>
<td>分组</td>
<td>写法例子为\(…\)</td>
<td>写法例子为(…)</td>
</tr>
<tr>
<td>在括号分组后面指定分组出现次数</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>反向引用</td>
<td>写法例子为<code>\1</code></td>
<td></td>
</tr>
<tr>
<td>用竖线表示多种情况匹配</td>
<td></td>
<td>支持</td>
</tr>
</tbody>
</table>
<p>我们现在使用的linux发行版，都是集成GNU套件的，GNU是Gnu’s Not Unix的缩写，GNU在实现了POXIS标准的同时，做了一定的扩展，所以上面空白栏中的功能也能使用。下面一一讲解：</p>
<ol>
<li>BRE如何使用<code>+</code>、<code>?</code>呢？需要用<code>\+</code>、<code>\?</code></li>
<li>BRE如何使用<code>|</code>呢？需要用<code>\|</code></li>
<li>ERE如何使用<code>\1</code>、<code>\2</code>等这样的反引用？和BRE一样，就是<code>\1</code>、<code>\2</code>等等</li>
</ol>
<p>－ <strong>(默认)</strong>使用BRE语法的命令有：grep、ed、sed、vim<br>－ <strong>(默认)</strong>使用ERE语法的命令有：egrep、awk、emacs</p>
<p>注意上面说的是默认情况下,比如 <code>sed</code> 通过 <code>-r</code> 选项就可以使用ERE了，大家到时自己man一下就可以了。</p>
<p>POSIX还定义了一些shorthand，具体如下：</p>
<ul>
<li>[:alnum:]</li>
<li>[:alpha:]</li>
<li>[:cntrl:]</li>
<li>[:digit:]</li>
<li>[:graph:]</li>
<li>[:lower:]</li>
<li>[:print:]</li>
<li>[:punct:]</li>
<li>[:space:]</li>
<li>[:upper:]</li>
<li>[:xdigit:]</li>
</ul>
<p>在使用这些shorthand时有一个约束：必须在[]中使用，也就是说如果像匹配0-9的数字，需要这么写[[:alnum:]]，取反就是[^[:alnum:]]。shorhand 在BRE与EBE中的用法相同。</p>
<p>如果用多了sed或者awk会发现,\w,\d这些用不了,因为POSIX规范根本没有定义这些shorthand,这些是在PCRE中定义的。</p>
<h2 id="PCRE标准"><a href="#PCRE标准" class="headerlink" title="PCRE标准"></a>PCRE标准</h2><p>前面说到,以前随着Perl的不断发展，其支持的正则表达式的功能也越来越强大。Perl比较显诸特征之一是与sed与awk兼容，这造就了Perl成为第一个通用性脚本语言。</p>
<p>Perl语言应用是如此广泛，以至于其他语言开始移植Perl，最终Perl compatible（兼容）的PCRE诞生了，这其中包括了Tcl, Python, Microsoft’s .NET , Ruby, PHP, C/C++, Java等等。</p>
<p>shorthand在POSIX与PCRE是不同的，PCRE中我们常用的有如下这些：</p>
<ul>
<li><code>\w</code> 表示<code>[a-zA-Z]</code></li>
<li><code>\W</code> 表示<code>[^a-zA-Z]</code></li>
<li><code>\s</code> 表示<code>[\t\r\n\f]</code></li>
<li><code>\S</code> 表示<code>[^\t\r\n\f]</code></li>
<li><code>\d</code> 表示<code>[1-9]</code></li>
<li><code>\D</code> 表示<code>[^1-9]</code></li>
<li><code>\&lt;</code> 表示一个单词的起始</li>
<li><code>\&gt;</code> 表示一个单词的结尾</li>
<li><code>\b</code> 代表着单词的开头或结尾,也就是单词的分界处,它只匹配一个位置</li>
</ul>
<h1 id="正则使用时候的注意点"><a href="#正则使用时候的注意点" class="headerlink" title="正则使用时候的注意点"></a>正则使用时候的注意点</h1><h2 id="关于哪个工具用的哪个正则标准"><a href="#关于哪个工具用的哪个正则标准" class="headerlink" title="关于哪个工具用的哪个正则标准"></a>关于哪个工具用的哪个正则标准</h2><p>记住一点,在某个语言中,像 Java、Python等,这些语言的正则表达式都是基于PCRE标准的;而Linux下使用各种处理文本的命令，是继承自POSIX标准，不过是由GNU扩展后的而已。<br><strong>注意,因为平时在编程语言里面用正则的多些,所以下面的注意点都是以PCRE标准说的.等下不要说我怎么在awk中测试不通过就尴尬了^_^.</strong></p>
<h2 id="正则的匹配方式"><a href="#正则的匹配方式" class="headerlink" title="正则的匹配方式"></a>正则的匹配方式</h2><p>正则是从左到右,依次匹配,如果匹配完了,作为第一个匹配结果,这个时候如果还没到字符串末尾,则再继续往后匹配,如果还能再匹配上,作为第二个匹配结果,直到遍历完该字符串,匹配结束,然后匹配结果会按照括号进行分组,分组从1下标开始,如果是0下标表示整个匹配到的字符串,下面有一个例子</p>
<p><img src="2017-09-28 11-48-39.png" alt="匹配例子"></p>
<h2 id="正则的处理选项"><a href="#正则的处理选项" class="headerlink" title="正则的处理选项"></a>正则的处理选项</h2><p><strong>单行模式和多行模式要特别注意下</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>IgnoreCase(忽略大小写)</td>
<td>匹配时不区分大小写。</td>
</tr>
<tr>
<td>Multiline(多行模式)</td>
<td>更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(<strong>在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.</strong>)</td>
</tr>
<tr>
<td>Singleline(单行模式)</td>
<td>更改.的含义，使它与每一个字符匹配（<strong>包括换行符\n</strong>）。</td>
</tr>
<tr>
<td>IgnorePatternWhitespace(忽略空白)</td>
<td>忽略表达式中的非转义空白并启用由#标记的注释。</td>
</tr>
<tr>
<td>ExplicitCapture(显式捕获)</td>
<td>仅捕获已被显式命名的组。</td>
</tr>
</tbody>
</table>
<h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><p><code>I already explained that the regex engine is eager .</code></p>
<p>这话的意思很明显,说明正则默认情况下,都是很贪婪的,比如用<code>get|gettest</code>去匹配<code>gettest</code>,一匹配到get后,就认为已经匹配成功了该交替表达式,结束匹配,返回get.<br>再举个例子,比如用<code>\b(Get(Value)?|Set(Value)?)\b</code>去匹配<code>SetValue</code>,因为使用了交替表达式,到了<code>Set(Value)?</code>这步匹配,因为贪婪,所以尽量长的去匹配,所以最终匹配到的是<code>SetValue</code>.</p>
<p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例<code>a.*b</code>，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索<code>aabab</code>的话，它会匹配整个字符串<code>aabab</code>。这被称为贪婪匹配。</p>
<p>有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。限定符可以把贪婪模式转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：</p>
<p><code>a.*?b</code>匹配最短的，以a开始，以b结束的字符串。如果把它应用于<code>aabab</code>的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。</p>
<p>懒惰限定符:</p>
<table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*?</td>
<td>重复任意次，但尽可能少重复</td>
</tr>
<tr>
<td>+?</td>
<td>重复1次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td>??</td>
<td>重复0次或1次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,m}?</td>
<td>重复n到m次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,}?</td>
<td>重复n次以上，但尽可能少重复</td>
</tr>
</tbody>
</table>
<h2 id="时刻记得转义的存在"><a href="#时刻记得转义的存在" class="headerlink" title="时刻记得转义的存在"></a>时刻记得转义的存在</h2><p>比如你要查找<code>*</code>字符,这个字符在正则里面有特殊的意义,所以你得写成<code>\*</code>才能真正匹配到<code>*</code>,就跟程序里面写字符串要进行转义一样.这里还有个注意点,比如你想找<code>|</code>,正则就得写成<code>\|</code>,但是到了程序里面,又得多一层转义用来转义<code>\</code>这个字符,所以程序里面得写成 <code>String regex=&quot;\\|&quot;</code></p>
<h2 id="字符类的否定（negation）"><a href="#字符类的否定（negation）" class="headerlink" title="字符类的否定（negation）"></a>字符类的否定（negation）</h2><p>你可以通过在最开始的位置使用插入符号（译者注：^）来_否定_一个字符类。</p>
<p>[^a]表示“匹配除了a的任意字符”。<br>[^a-zA-Z0-9]表示“找到一个非字母数字字符”。<br>[\^abc]表示“找到一个插入符或者a或者b或者c”。<br>[^\^]表示“找到除了插入符外的任意字符”。（呕！）</p>
<h2 id="分组的使用"><a href="#分组的使用" class="headerlink" title="分组的使用"></a>分组的使用</h2><p>分组的使用这里我遇到几种情况:</p>
<ol>
<li>分组命名</li>
<li>忽略分组</li>
<li>嵌套分组</li>
<li>反向引用分组</li>
</ol>
<p>关于嵌套分组的有总结得比较好的,就不解释了:<br><img src="/posts/37573/2017-09-28%2015-50-57.png" title="嵌套分组"></p>
<p>剩下的直接上例子最好说明了:<br><img src="/posts/37573/2017-09-28%2011-24-11.png" title="使用分组"><br><img src="/posts/37573/2017-09-28%2015-30-36.png" title="使用分组命名并引用相应命名的分组"><br><img src="/posts/37573/2017-09-28%2015-35-36.png" title="忽略分组"><br><img src="/posts/37573/2017-09-28%2011-24-57.png" title="使用分组并反向引用分组"></p>
<h2 id="零宽断言和负向零宽断言"><a href="#零宽断言和负向零宽断言" class="headerlink" title="零宽断言和负向零宽断言"></a>零宽断言和负向零宽断言</h2><h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><p>通俗点讲,就是限制需要匹配的字符串前后能有什么,不能有什么.</p>
<p><code>(?=exp)</code>也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如<code>\b\w+(?=ing\b)</code>，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找<code>I&#39;m singing while you&#39;re dancing.</code>时，它会匹配<code>sing</code>和<code>danc</code>。</p>
<p><code>(?&lt;=exp)</code>也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如<code>(?&lt;=\bre)\w+\b</code>会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找<code>reading a book</code>时，它匹配<code>ading</code>。</p>
<p>下面这个例子同时使用了这两种断言<code>(?&lt;=\s)\d+(?=\s)</code>匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p>
<h3 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h3><p>那有了这个<strong>零宽断言</strong>,为什么还要有另外一个<strong>负向零宽断言</strong>呢?</p>
<p>看下下面的例子(引用,因为这个例子已经足够好说明了):</p>
<img src="/posts/37573/2017-09-28%2015-12-03.png" title="匹配包含p但是后面不要带有u的单词">
<p><code>(?!exp)</code>，断言此位置的后面不能匹配表达式exp。它只匹配一个位置，并不消费任何字符。<br><code>(?&lt;!exp)</code>，断言此位置的前面不能匹配表达式exp。它只匹配一个位置，并不消费任何字符。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总算写完了这篇文章,参考了许多资料,一开始接触awk,sed程序发现,跟java里面用的正则又不太一样,才有了后面去探索为什么有这些区别,顺便翻了下正则的发展史,总的来说正则的使用思路才清晰了些.这里只是把一些常用的用法在这里做了下汇总和总结,有错误的地方欢迎指正.</p>
<p>在java中,用<code>Pattern.compile(String inputString)</code>来产生一个<code>Pattern</code>类,<code>Pattern</code>类通过<code>Pattern.matcher(String regexString)</code>产生一个<code>Matcher</code>类,该<code>Matcher</code>类有group(用来获取分组)方法,start 和 end 方法,matches 和 lookingAt 方法,replaceFirst 和 replaceAll 方法,appendReplacement 和 appendTail 方法,具体使用详情请看: <a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener">菜鸟教程</a> ;快速测试java代码,可以在线使用 <a href="http://www.javarepl.com/term.html" target="_blank" rel="noopener">Java Repl</a> 检验下.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在js中,正则表达式中/i,/g,/ig,/gi,/m的区别和含义</span><br><span class="line">/i (忽略大小写)</span><br><span class="line">/g (全文查找出现的所有匹配字符)</span><br><span class="line">/m (多行查找)</span><br><span class="line">/gi(全文查找、忽略大小写)</span><br><span class="line">/ig(全文查找、忽略大小写)</span><br><span class="line">参考文献:http://deerchao.net/tutorials/regex/regex.htm</span><br></pre></td></tr></table></figure>
<p>而有关正则的原理,则涉及到状态机,回溯那些东西,有机会再写下自己的理解^_^</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参考资料: </span><br><span class="line">正则表达式的详细说明(英文版):</span><br><span class="line">https://www.regular-expressions.info/tutorial.html</span><br><span class="line"></span><br><span class="line">正则标准详细说明:</span><br><span class="line">http://liujiacai.net/blog/2014/12/07/regexp-favors/</span><br><span class="line">http://www.infoq.com/cn/news/2011/07/regular-expressions-6-POSIX</span><br><span class="line"></span><br><span class="line">PCRE标准的可以看:</span><br><span class="line">http://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html</span><br><span class="line"></span><br><span class="line">关于正则分组的使用(有程序例子):</span><br><span class="line">https://segmentfault.com/a/1190000004429477</span><br><span class="line"></span><br><span class="line">sed的教程:</span><br><span class="line">http://coolshell.cn/articles/9104.html</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p><strong>版权声明:</strong><br>本文首发于<a href="https://godtree94.github.io">GODTREE 博客</a>，版权所有，侵权必究，转载请注明出处。<br>本文永久链接：<a href="https://godtree94.github.io/posts/37573/">https://godtree94.github.io/posts/37573/</a></p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
</search>
